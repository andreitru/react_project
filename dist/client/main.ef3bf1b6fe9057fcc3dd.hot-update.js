webpackHotUpdate("main",{

/***/ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar setPrototypeOf_1 = __importDefault(__webpack_require__(/*! @babel/runtime/helpers/esm/setPrototypeOf */ \"./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\"));\nfunction _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    setPrototypeOf_1.default(subClass, superClass);\n}\nexports.default = _inheritsLoose;\n\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction _setPrototypeOf(o, p) {\n    exports._setPrototypeOf = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nexports.default = _setPrototypeOf;\n\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js?");

/***/ }),

/***/ "./node_modules/history/esm/history.js":
/*!*********************************************!*\
  !*** ./node_modules/history/esm/history.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createPath = exports.parsePath = exports.locationsAreEqual = exports.createLocation = exports.createMemoryHistory = exports.createHashHistory = exports.createBrowserHistory = void 0;\nvar extends_1 = __importDefault(__webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"./node_modules/@babel/runtime/helpers/esm/extends.js\"));\nvar resolve_pathname_1 = __importDefault(__webpack_require__(/*! resolve-pathname */ \"./node_modules/resolve-pathname/esm/resolve-pathname.js\"));\nvar value_equal_1 = __importDefault(__webpack_require__(/*! value-equal */ \"./node_modules/value-equal/esm/value-equal.js\"));\nvar tiny_warning_1 = __importDefault(__webpack_require__(/*! tiny-warning */ \"./node_modules/tiny-warning/dist/tiny-warning.esm.js\"));\nvar tiny_invariant_1 = __importDefault(__webpack_require__(/*! tiny-invariant */ \"./node_modules/tiny-invariant/dist/tiny-invariant.esm.js\"));\nfunction addLeadingSlash(path) {\n    return path.charAt(0) === '/' ? path : '/' + path;\n}\nfunction stripLeadingSlash(path) {\n    return path.charAt(0) === '/' ? path.substr(1) : path;\n}\nfunction hasBasename(path, prefix) {\n    return path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 && '/?#'.indexOf(path.charAt(prefix.length)) !== -1;\n}\nfunction stripBasename(path, prefix) {\n    return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\n}\nfunction stripTrailingSlash(path) {\n    return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;\n}\nfunction parsePath(path) {\n    var pathname = path || '/';\n    var search = '';\n    var hash = '';\n    var hashIndex = pathname.indexOf('#');\n    if (hashIndex !== -1) {\n        hash = pathname.substr(hashIndex);\n        pathname = pathname.substr(0, hashIndex);\n    }\n    var searchIndex = pathname.indexOf('?');\n    if (searchIndex !== -1) {\n        search = pathname.substr(searchIndex);\n        pathname = pathname.substr(0, searchIndex);\n    }\n    return {\n        pathname: pathname,\n        search: search === '?' ? '' : search,\n        hash: hash === '#' ? '' : hash\n    };\n}\nexports.parsePath = parsePath;\nfunction createPath(location) {\n    var pathname = location.pathname, search = location.search, hash = location.hash;\n    var path = pathname || '/';\n    if (search && search !== '?')\n        path += search.charAt(0) === '?' ? search : \"?\" + search;\n    if (hash && hash !== '#')\n        path += hash.charAt(0) === '#' ? hash : \"#\" + hash;\n    return path;\n}\nexports.createPath = createPath;\nfunction createLocation(path, state, key, currentLocation) {\n    var location;\n    if (typeof path === 'string') {\n        // Two-arg form: push(path, state)\n        location = parsePath(path);\n        location.state = state;\n    }\n    else {\n        // One-arg form: push(location)\n        location = extends_1.default({}, path);\n        if (location.pathname === undefined)\n            location.pathname = '';\n        if (location.search) {\n            if (location.search.charAt(0) !== '?')\n                location.search = '?' + location.search;\n        }\n        else {\n            location.search = '';\n        }\n        if (location.hash) {\n            if (location.hash.charAt(0) !== '#')\n                location.hash = '#' + location.hash;\n        }\n        else {\n            location.hash = '';\n        }\n        if (state !== undefined && location.state === undefined)\n            location.state = state;\n    }\n    try {\n        location.pathname = decodeURI(location.pathname);\n    }\n    catch (e) {\n        if (e instanceof URIError) {\n            throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');\n        }\n        else {\n            throw e;\n        }\n    }\n    if (key)\n        location.key = key;\n    if (currentLocation) {\n        // Resolve incomplete/relative pathname relative to current location.\n        if (!location.pathname) {\n            location.pathname = currentLocation.pathname;\n        }\n        else if (location.pathname.charAt(0) !== '/') {\n            location.pathname = resolve_pathname_1.default(location.pathname, currentLocation.pathname);\n        }\n    }\n    else {\n        // When there is no prior location and pathname is empty, set it to /\n        if (!location.pathname) {\n            location.pathname = '/';\n        }\n    }\n    return location;\n}\nexports.createLocation = createLocation;\nfunction locationsAreEqual(a, b) {\n    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && value_equal_1.default(a.state, b.state);\n}\nexports.locationsAreEqual = locationsAreEqual;\nfunction createTransitionManager() {\n    var prompt = null;\n    function setPrompt(nextPrompt) {\n         true ? tiny_warning_1.default(prompt == null, 'A history supports only one prompt at a time') : undefined;\n        prompt = nextPrompt;\n        return function () {\n            if (prompt === nextPrompt)\n                prompt = null;\n        };\n    }\n    function confirmTransitionTo(location, action, getUserConfirmation, callback) {\n        // TODO: If another transition starts while we're still confirming\n        // the previous one, we may end up in a weird state. Figure out the\n        // best way to handle this.\n        if (prompt != null) {\n            var result = typeof prompt === 'function' ? prompt(location, action) : prompt;\n            if (typeof result === 'string') {\n                if (typeof getUserConfirmation === 'function') {\n                    getUserConfirmation(result, callback);\n                }\n                else {\n                     true ? tiny_warning_1.default(false, 'A history needs a getUserConfirmation function in order to use a prompt message') : undefined;\n                    callback(true);\n                }\n            }\n            else {\n                // Return false from a transition hook to cancel the transition.\n                callback(result !== false);\n            }\n        }\n        else {\n            callback(true);\n        }\n    }\n    var listeners = [];\n    function appendListener(fn) {\n        var isActive = true;\n        function listener() {\n            if (isActive)\n                fn.apply(void 0, arguments);\n        }\n        listeners.push(listener);\n        return function () {\n            isActive = false;\n            listeners = listeners.filter(function (item) {\n                return item !== listener;\n            });\n        };\n    }\n    function notifyListeners() {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n        listeners.forEach(function (listener) {\n            return listener.apply(void 0, args);\n        });\n    }\n    return {\n        setPrompt: setPrompt,\n        confirmTransitionTo: confirmTransitionTo,\n        appendListener: appendListener,\n        notifyListeners: notifyListeners\n    };\n}\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\nfunction getConfirmation(message, callback) {\n    callback(window.confirm(message)); // eslint-disable-line no-alert\n}\n/**\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\n *\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\n */\nfunction supportsHistory() {\n    var ua = window.navigator.userAgent;\n    if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1)\n        return false;\n    return window.history && 'pushState' in window.history;\n}\n/**\n * Returns true if browser fires popstate on hash change.\n * IE10 and IE11 do not.\n */\nfunction supportsPopStateOnHashChange() {\n    return window.navigator.userAgent.indexOf('Trident') === -1;\n}\n/**\n * Returns false if using go(n) with hash history causes a full page reload.\n */\nfunction supportsGoWithoutReloadUsingHash() {\n    return window.navigator.userAgent.indexOf('Firefox') === -1;\n}\n/**\n * Returns true if a given popstate event is an extraneous WebKit event.\n * Accounts for the fact that Chrome on iOS fires real popstate events\n * containing undefined state when pressing the back button.\n */\nfunction isExtraneousPopstateEvent(event) {\n    return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;\n}\nvar PopStateEvent = 'popstate';\nvar HashChangeEvent = 'hashchange';\nfunction getHistoryState() {\n    try {\n        return window.history.state || {};\n    }\n    catch (e) {\n        // IE 11 sometimes throws when accessing window.history.state\n        // See https://github.com/ReactTraining/history/pull/289\n        return {};\n    }\n}\n/**\n * Creates a history object that uses the HTML5 history API including\n * pushState, replaceState, and the popstate event.\n */\nfunction createBrowserHistory(props) {\n    if (props === void 0) {\n        props = {};\n    }\n    !canUseDOM ?  true ? tiny_invariant_1.default(false, 'Browser history needs a DOM') : undefined : void 0;\n    var globalHistory = window.history;\n    var canUseHistory = supportsHistory();\n    var needsHashChangeListener = !supportsPopStateOnHashChange();\n    var _props = props, _props$forceRefresh = _props.forceRefresh, forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;\n    var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\n    function getDOMLocation(historyState) {\n        var _ref = historyState || {}, key = _ref.key, state = _ref.state;\n        var _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash;\n        var path = pathname + search + hash;\n         true ? tiny_warning_1.default(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".') : undefined;\n        if (basename)\n            path = stripBasename(path, basename);\n        return createLocation(path, state, key);\n    }\n    function createKey() {\n        return Math.random().toString(36).substr(2, keyLength);\n    }\n    var transitionManager = createTransitionManager();\n    function setState(nextState) {\n        extends_1.default(history, nextState);\n        history.length = globalHistory.length;\n        transitionManager.notifyListeners(history.location, history.action);\n    }\n    function handlePopState(event) {\n        // Ignore extraneous popstate events in WebKit.\n        if (isExtraneousPopstateEvent(event))\n            return;\n        handlePop(getDOMLocation(event.state));\n    }\n    function handleHashChange() {\n        handlePop(getDOMLocation(getHistoryState()));\n    }\n    var forceNextPop = false;\n    function handlePop(location) {\n        if (forceNextPop) {\n            forceNextPop = false;\n            setState();\n        }\n        else {\n            var action = 'POP';\n            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n                if (ok) {\n                    setState({\n                        action: action,\n                        location: location\n                    });\n                }\n                else {\n                    revertPop(location);\n                }\n            });\n        }\n    }\n    function revertPop(fromLocation) {\n        var toLocation = history.location; // TODO: We could probably make this more reliable by\n        // keeping a list of keys we've seen in sessionStorage.\n        // Instead, we just default to 0 for keys we don't know.\n        var toIndex = allKeys.indexOf(toLocation.key);\n        if (toIndex === -1)\n            toIndex = 0;\n        var fromIndex = allKeys.indexOf(fromLocation.key);\n        if (fromIndex === -1)\n            fromIndex = 0;\n        var delta = toIndex - fromIndex;\n        if (delta) {\n            forceNextPop = true;\n            go(delta);\n        }\n    }\n    var initialLocation = getDOMLocation(getHistoryState());\n    var allKeys = [initialLocation.key]; // Public interface\n    function createHref(location) {\n        return basename + createPath(location);\n    }\n    function push(path, state) {\n         true ? tiny_warning_1.default(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : undefined;\n        var action = 'PUSH';\n        var location = createLocation(path, state, createKey(), history.location);\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n            if (!ok)\n                return;\n            var href = createHref(location);\n            var key = location.key, state = location.state;\n            if (canUseHistory) {\n                globalHistory.pushState({\n                    key: key,\n                    state: state\n                }, null, href);\n                if (forceRefresh) {\n                    window.location.href = href;\n                }\n                else {\n                    var prevIndex = allKeys.indexOf(history.location.key);\n                    var nextKeys = allKeys.slice(0, prevIndex + 1);\n                    nextKeys.push(location.key);\n                    allKeys = nextKeys;\n                    setState({\n                        action: action,\n                        location: location\n                    });\n                }\n            }\n            else {\n                 true ? tiny_warning_1.default(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history') : undefined;\n                window.location.href = href;\n            }\n        });\n    }\n    function replace(path, state) {\n         true ? tiny_warning_1.default(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : undefined;\n        var action = 'REPLACE';\n        var location = createLocation(path, state, createKey(), history.location);\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n            if (!ok)\n                return;\n            var href = createHref(location);\n            var key = location.key, state = location.state;\n            if (canUseHistory) {\n                globalHistory.replaceState({\n                    key: key,\n                    state: state\n                }, null, href);\n                if (forceRefresh) {\n                    window.location.replace(href);\n                }\n                else {\n                    var prevIndex = allKeys.indexOf(history.location.key);\n                    if (prevIndex !== -1)\n                        allKeys[prevIndex] = location.key;\n                    setState({\n                        action: action,\n                        location: location\n                    });\n                }\n            }\n            else {\n                 true ? tiny_warning_1.default(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history') : undefined;\n                window.location.replace(href);\n            }\n        });\n    }\n    function go(n) {\n        globalHistory.go(n);\n    }\n    function goBack() {\n        go(-1);\n    }\n    function goForward() {\n        go(1);\n    }\n    var listenerCount = 0;\n    function checkDOMListeners(delta) {\n        listenerCount += delta;\n        if (listenerCount === 1 && delta === 1) {\n            window.addEventListener(PopStateEvent, handlePopState);\n            if (needsHashChangeListener)\n                window.addEventListener(HashChangeEvent, handleHashChange);\n        }\n        else if (listenerCount === 0) {\n            window.removeEventListener(PopStateEvent, handlePopState);\n            if (needsHashChangeListener)\n                window.removeEventListener(HashChangeEvent, handleHashChange);\n        }\n    }\n    var isBlocked = false;\n    function block(prompt) {\n        if (prompt === void 0) {\n            prompt = false;\n        }\n        var unblock = transitionManager.setPrompt(prompt);\n        if (!isBlocked) {\n            checkDOMListeners(1);\n            isBlocked = true;\n        }\n        return function () {\n            if (isBlocked) {\n                isBlocked = false;\n                checkDOMListeners(-1);\n            }\n            return unblock();\n        };\n    }\n    function listen(listener) {\n        var unlisten = transitionManager.appendListener(listener);\n        checkDOMListeners(1);\n        return function () {\n            checkDOMListeners(-1);\n            unlisten();\n        };\n    }\n    var history = {\n        length: globalHistory.length,\n        action: 'POP',\n        location: initialLocation,\n        createHref: createHref,\n        push: push,\n        replace: replace,\n        go: go,\n        goBack: goBack,\n        goForward: goForward,\n        block: block,\n        listen: listen\n    };\n    return history;\n}\nexports.createBrowserHistory = createBrowserHistory;\nvar HashChangeEvent$1 = 'hashchange';\nvar HashPathCoders = {\n    hashbang: {\n        encodePath: function encodePath(path) {\n            return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);\n        },\n        decodePath: function decodePath(path) {\n            return path.charAt(0) === '!' ? path.substr(1) : path;\n        }\n    },\n    noslash: {\n        encodePath: stripLeadingSlash,\n        decodePath: addLeadingSlash\n    },\n    slash: {\n        encodePath: addLeadingSlash,\n        decodePath: addLeadingSlash\n    }\n};\nfunction stripHash(url) {\n    var hashIndex = url.indexOf('#');\n    return hashIndex === -1 ? url : url.slice(0, hashIndex);\n}\nfunction getHashPath() {\n    // We can't use window.location.hash here because it's not\n    // consistent across browsers - Firefox will pre-decode it!\n    var href = window.location.href;\n    var hashIndex = href.indexOf('#');\n    return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\n}\nfunction pushHashPath(path) {\n    window.location.hash = path;\n}\nfunction replaceHashPath(path) {\n    window.location.replace(stripHash(window.location.href) + '#' + path);\n}\nfunction createHashHistory(props) {\n    if (props === void 0) {\n        props = {};\n    }\n    !canUseDOM ?  true ? tiny_invariant_1.default(false, 'Hash history needs a DOM') : undefined : void 0;\n    var globalHistory = window.history;\n    var canGoWithoutReload = supportsGoWithoutReloadUsingHash();\n    var _props = props, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$hashType = _props.hashType, hashType = _props$hashType === void 0 ? 'slash' : _props$hashType;\n    var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\n    var _HashPathCoders$hashT = HashPathCoders[hashType], encodePath = _HashPathCoders$hashT.encodePath, decodePath = _HashPathCoders$hashT.decodePath;\n    function getDOMLocation() {\n        var path = decodePath(getHashPath());\n         true ? tiny_warning_1.default(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".') : undefined;\n        if (basename)\n            path = stripBasename(path, basename);\n        return createLocation(path);\n    }\n    var transitionManager = createTransitionManager();\n    function setState(nextState) {\n        extends_1.default(history, nextState);\n        history.length = globalHistory.length;\n        transitionManager.notifyListeners(history.location, history.action);\n    }\n    var forceNextPop = false;\n    var ignorePath = null;\n    function locationsAreEqual$$1(a, b) {\n        return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;\n    }\n    function handleHashChange() {\n        var path = getHashPath();\n        var encodedPath = encodePath(path);\n        if (path !== encodedPath) {\n            // Ensure we always have a properly-encoded hash.\n            replaceHashPath(encodedPath);\n        }\n        else {\n            var location = getDOMLocation();\n            var prevLocation = history.location;\n            if (!forceNextPop && locationsAreEqual$$1(prevLocation, location))\n                return; // A hashchange doesn't always == location change.\n            if (ignorePath === createPath(location))\n                return; // Ignore this change; we already setState in push/replace.\n            ignorePath = null;\n            handlePop(location);\n        }\n    }\n    function handlePop(location) {\n        if (forceNextPop) {\n            forceNextPop = false;\n            setState();\n        }\n        else {\n            var action = 'POP';\n            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n                if (ok) {\n                    setState({\n                        action: action,\n                        location: location\n                    });\n                }\n                else {\n                    revertPop(location);\n                }\n            });\n        }\n    }\n    function revertPop(fromLocation) {\n        var toLocation = history.location; // TODO: We could probably make this more reliable by\n        // keeping a list of paths we've seen in sessionStorage.\n        // Instead, we just default to 0 for paths we don't know.\n        var toIndex = allPaths.lastIndexOf(createPath(toLocation));\n        if (toIndex === -1)\n            toIndex = 0;\n        var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));\n        if (fromIndex === -1)\n            fromIndex = 0;\n        var delta = toIndex - fromIndex;\n        if (delta) {\n            forceNextPop = true;\n            go(delta);\n        }\n    } // Ensure the hash is encoded properly before doing anything else.\n    var path = getHashPath();\n    var encodedPath = encodePath(path);\n    if (path !== encodedPath)\n        replaceHashPath(encodedPath);\n    var initialLocation = getDOMLocation();\n    var allPaths = [createPath(initialLocation)]; // Public interface\n    function createHref(location) {\n        var baseTag = document.querySelector('base');\n        var href = '';\n        if (baseTag && baseTag.getAttribute('href')) {\n            href = stripHash(window.location.href);\n        }\n        return href + '#' + encodePath(basename + createPath(location));\n    }\n    function push(path, state) {\n         true ? tiny_warning_1.default(state === undefined, 'Hash history cannot push state; it is ignored') : undefined;\n        var action = 'PUSH';\n        var location = createLocation(path, undefined, undefined, history.location);\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n            if (!ok)\n                return;\n            var path = createPath(location);\n            var encodedPath = encodePath(basename + path);\n            var hashChanged = getHashPath() !== encodedPath;\n            if (hashChanged) {\n                // We cannot tell if a hashchange was caused by a PUSH, so we'd\n                // rather setState here and ignore the hashchange. The caveat here\n                // is that other hash histories in the page will consider it a POP.\n                ignorePath = path;\n                pushHashPath(encodedPath);\n                var prevIndex = allPaths.lastIndexOf(createPath(history.location));\n                var nextPaths = allPaths.slice(0, prevIndex + 1);\n                nextPaths.push(path);\n                allPaths = nextPaths;\n                setState({\n                    action: action,\n                    location: location\n                });\n            }\n            else {\n                 true ? tiny_warning_1.default(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack') : undefined;\n                setState();\n            }\n        });\n    }\n    function replace(path, state) {\n         true ? tiny_warning_1.default(state === undefined, 'Hash history cannot replace state; it is ignored') : undefined;\n        var action = 'REPLACE';\n        var location = createLocation(path, undefined, undefined, history.location);\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n            if (!ok)\n                return;\n            var path = createPath(location);\n            var encodedPath = encodePath(basename + path);\n            var hashChanged = getHashPath() !== encodedPath;\n            if (hashChanged) {\n                // We cannot tell if a hashchange was caused by a REPLACE, so we'd\n                // rather setState here and ignore the hashchange. The caveat here\n                // is that other hash histories in the page will consider it a POP.\n                ignorePath = path;\n                replaceHashPath(encodedPath);\n            }\n            var prevIndex = allPaths.indexOf(createPath(history.location));\n            if (prevIndex !== -1)\n                allPaths[prevIndex] = path;\n            setState({\n                action: action,\n                location: location\n            });\n        });\n    }\n    function go(n) {\n         true ? tiny_warning_1.default(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : undefined;\n        globalHistory.go(n);\n    }\n    function goBack() {\n        go(-1);\n    }\n    function goForward() {\n        go(1);\n    }\n    var listenerCount = 0;\n    function checkDOMListeners(delta) {\n        listenerCount += delta;\n        if (listenerCount === 1 && delta === 1) {\n            window.addEventListener(HashChangeEvent$1, handleHashChange);\n        }\n        else if (listenerCount === 0) {\n            window.removeEventListener(HashChangeEvent$1, handleHashChange);\n        }\n    }\n    var isBlocked = false;\n    function block(prompt) {\n        if (prompt === void 0) {\n            prompt = false;\n        }\n        var unblock = transitionManager.setPrompt(prompt);\n        if (!isBlocked) {\n            checkDOMListeners(1);\n            isBlocked = true;\n        }\n        return function () {\n            if (isBlocked) {\n                isBlocked = false;\n                checkDOMListeners(-1);\n            }\n            return unblock();\n        };\n    }\n    function listen(listener) {\n        var unlisten = transitionManager.appendListener(listener);\n        checkDOMListeners(1);\n        return function () {\n            checkDOMListeners(-1);\n            unlisten();\n        };\n    }\n    var history = {\n        length: globalHistory.length,\n        action: 'POP',\n        location: initialLocation,\n        createHref: createHref,\n        push: push,\n        replace: replace,\n        go: go,\n        goBack: goBack,\n        goForward: goForward,\n        block: block,\n        listen: listen\n    };\n    return history;\n}\nexports.createHashHistory = createHashHistory;\nfunction clamp(n, lowerBound, upperBound) {\n    return Math.min(Math.max(n, lowerBound), upperBound);\n}\n/**\n * Creates a history object that stores locations in memory.\n */\nfunction createMemoryHistory(props) {\n    if (props === void 0) {\n        props = {};\n    }\n    var _props = props, getUserConfirmation = _props.getUserConfirmation, _props$initialEntries = _props.initialEntries, initialEntries = _props$initialEntries === void 0 ? ['/'] : _props$initialEntries, _props$initialIndex = _props.initialIndex, initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;\n    var transitionManager = createTransitionManager();\n    function setState(nextState) {\n        extends_1.default(history, nextState);\n        history.length = history.entries.length;\n        transitionManager.notifyListeners(history.location, history.action);\n    }\n    function createKey() {\n        return Math.random().toString(36).substr(2, keyLength);\n    }\n    var index = clamp(initialIndex, 0, initialEntries.length - 1);\n    var entries = initialEntries.map(function (entry) {\n        return typeof entry === 'string' ? createLocation(entry, undefined, createKey()) : createLocation(entry, undefined, entry.key || createKey());\n    }); // Public interface\n    var createHref = createPath;\n    function push(path, state) {\n         true ? tiny_warning_1.default(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : undefined;\n        var action = 'PUSH';\n        var location = createLocation(path, state, createKey(), history.location);\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n            if (!ok)\n                return;\n            var prevIndex = history.index;\n            var nextIndex = prevIndex + 1;\n            var nextEntries = history.entries.slice(0);\n            if (nextEntries.length > nextIndex) {\n                nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);\n            }\n            else {\n                nextEntries.push(location);\n            }\n            setState({\n                action: action,\n                location: location,\n                index: nextIndex,\n                entries: nextEntries\n            });\n        });\n    }\n    function replace(path, state) {\n         true ? tiny_warning_1.default(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : undefined;\n        var action = 'REPLACE';\n        var location = createLocation(path, state, createKey(), history.location);\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n            if (!ok)\n                return;\n            history.entries[history.index] = location;\n            setState({\n                action: action,\n                location: location\n            });\n        });\n    }\n    function go(n) {\n        var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);\n        var action = 'POP';\n        var location = history.entries[nextIndex];\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n            if (ok) {\n                setState({\n                    action: action,\n                    location: location,\n                    index: nextIndex\n                });\n            }\n            else {\n                // Mimic the behavior of DOM histories by\n                // causing a render after a cancelled POP.\n                setState();\n            }\n        });\n    }\n    function goBack() {\n        go(-1);\n    }\n    function goForward() {\n        go(1);\n    }\n    function canGo(n) {\n        var nextIndex = history.index + n;\n        return nextIndex >= 0 && nextIndex < history.entries.length;\n    }\n    function block(prompt) {\n        if (prompt === void 0) {\n            prompt = false;\n        }\n        return transitionManager.setPrompt(prompt);\n    }\n    function listen(listener) {\n        return transitionManager.appendListener(listener);\n    }\n    var history = {\n        length: entries.length,\n        action: 'POP',\n        location: entries[index],\n        index: index,\n        entries: entries,\n        createHref: createHref,\n        push: push,\n        replace: replace,\n        go: go,\n        goBack: goBack,\n        goForward: goForward,\n        canGo: canGo,\n        block: block,\n        listen: listen\n    };\n    return history;\n}\nexports.createMemoryHistory = createMemoryHistory;\n\n\n//# sourceURL=webpack:///./node_modules/history/esm/history.js?");

/***/ }),

/***/ "./node_modules/mini-create-react-context/dist/esm/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/mini-create-react-context/dist/esm/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar inheritsLoose_1 = __importDefault(__webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ \"./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\"));\nvar prop_types_1 = __importDefault(__webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\"));\nvar tiny_warning_1 = __importDefault(__webpack_require__(/*! tiny-warning */ \"./node_modules/tiny-warning/dist/tiny-warning.esm.js\"));\nvar MAX_SIGNED_31_BIT_INT = 1073741823;\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {};\nfunction getUniqueId() {\n    var key = '__global_unique_id__';\n    return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;\n}\nfunction objectIs(x, y) {\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y;\n    }\n    else {\n        return x !== x && y !== y;\n    }\n}\nfunction createEventEmitter(value) {\n    var handlers = [];\n    return {\n        on: function on(handler) {\n            handlers.push(handler);\n        },\n        off: function off(handler) {\n            handlers = handlers.filter(function (h) {\n                return h !== handler;\n            });\n        },\n        get: function get() {\n            return value;\n        },\n        set: function set(newValue, changedBits) {\n            value = newValue;\n            handlers.forEach(function (handler) {\n                return handler(value, changedBits);\n            });\n        }\n    };\n}\nfunction onlyChild(children) {\n    return Array.isArray(children) ? children[0] : children;\n}\nfunction createReactContext(defaultValue, calculateChangedBits) {\n    var _Provider$childContex, _Consumer$contextType;\n    var contextProp = '__create-react-context-' + getUniqueId() + '__';\n    var Provider = /*#__PURE__*/ function (_Component) {\n        inheritsLoose_1.default(Provider, _Component);\n        function Provider() {\n            var _this;\n            _this = _Component.apply(this, arguments) || this;\n            _this.emitter = createEventEmitter(_this.props.value);\n            return _this;\n        }\n        var _proto = Provider.prototype;\n        _proto.getChildContext = function getChildContext() {\n            var _ref;\n            return _ref = {}, _ref[contextProp] = this.emitter, _ref;\n        };\n        _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n            if (this.props.value !== nextProps.value) {\n                var oldValue = this.props.value;\n                var newValue = nextProps.value;\n                var changedBits;\n                if (objectIs(oldValue, newValue)) {\n                    changedBits = 0;\n                }\n                else {\n                    changedBits = typeof calculateChangedBits === 'function' ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;\n                    if (true) {\n                        tiny_warning_1.default((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits, 'calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: ' + changedBits);\n                    }\n                    changedBits |= 0;\n                    if (changedBits !== 0) {\n                        this.emitter.set(nextProps.value, changedBits);\n                    }\n                }\n            }\n        };\n        _proto.render = function render() {\n            return this.props.children;\n        };\n        return Provider;\n    }(react_1.Component);\n    Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = prop_types_1.default.object.isRequired, _Provider$childContex);\n    var Consumer = /*#__PURE__*/ function (_Component2) {\n        inheritsLoose_1.default(Consumer, _Component2);\n        function Consumer() {\n            var _this2;\n            _this2 = _Component2.apply(this, arguments) || this;\n            _this2.state = {\n                value: _this2.getValue()\n            };\n            _this2.onUpdate = function (newValue, changedBits) {\n                var observedBits = _this2.observedBits | 0;\n                if ((observedBits & changedBits) !== 0) {\n                    _this2.setState({\n                        value: _this2.getValue()\n                    });\n                }\n            };\n            return _this2;\n        }\n        var _proto2 = Consumer.prototype;\n        _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n            var observedBits = nextProps.observedBits;\n            this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;\n        };\n        _proto2.componentDidMount = function componentDidMount() {\n            if (this.context[contextProp]) {\n                this.context[contextProp].on(this.onUpdate);\n            }\n            var observedBits = this.props.observedBits;\n            this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;\n        };\n        _proto2.componentWillUnmount = function componentWillUnmount() {\n            if (this.context[contextProp]) {\n                this.context[contextProp].off(this.onUpdate);\n            }\n        };\n        _proto2.getValue = function getValue() {\n            if (this.context[contextProp]) {\n                return this.context[contextProp].get();\n            }\n            else {\n                return defaultValue;\n            }\n        };\n        _proto2.render = function render() {\n            return onlyChild(this.props.children)(this.state.value);\n        };\n        return Consumer;\n    }(react_1.Component);\n    Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = prop_types_1.default.object, _Consumer$contextType);\n    return {\n        Provider: Provider,\n        Consumer: Consumer\n    };\n}\nvar index = react_1.default.createContext || createReactContext;\nexports.default = index;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/mini-create-react-context/dist/esm/index.js?");

/***/ }),

/***/ "./node_modules/react-router-dom/esm/react-router-dom.js":
/*!***************************************************************!*\
  !*** ./node_modules/react-router-dom/esm/react-router-dom.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NavLink = exports.Link = exports.HashRouter = exports.BrowserRouter = exports.withRouter = exports.useRouteMatch = exports.useParams = exports.useLocation = exports.useHistory = exports.matchPath = exports.generatePath = exports.Switch = exports.StaticRouter = exports.Router = exports.Route = exports.Redirect = exports.Prompt = exports.MemoryRouter = void 0;\nvar react_router_1 = __webpack_require__(/*! react-router */ \"./node_modules/react-router/esm/react-router.js\");\nvar react_router_2 = __webpack_require__(/*! react-router */ \"./node_modules/react-router/esm/react-router.js\");\nObject.defineProperty(exports, \"MemoryRouter\", { enumerable: true, get: function () { return react_router_2.MemoryRouter; } });\nObject.defineProperty(exports, \"Prompt\", { enumerable: true, get: function () { return react_router_2.Prompt; } });\nObject.defineProperty(exports, \"Redirect\", { enumerable: true, get: function () { return react_router_2.Redirect; } });\nObject.defineProperty(exports, \"Route\", { enumerable: true, get: function () { return react_router_2.Route; } });\nObject.defineProperty(exports, \"Router\", { enumerable: true, get: function () { return react_router_2.Router; } });\nObject.defineProperty(exports, \"StaticRouter\", { enumerable: true, get: function () { return react_router_2.StaticRouter; } });\nObject.defineProperty(exports, \"Switch\", { enumerable: true, get: function () { return react_router_2.Switch; } });\nObject.defineProperty(exports, \"generatePath\", { enumerable: true, get: function () { return react_router_2.generatePath; } });\nObject.defineProperty(exports, \"matchPath\", { enumerable: true, get: function () { return react_router_2.matchPath; } });\nObject.defineProperty(exports, \"useHistory\", { enumerable: true, get: function () { return react_router_2.useHistory; } });\nObject.defineProperty(exports, \"useLocation\", { enumerable: true, get: function () { return react_router_2.useLocation; } });\nObject.defineProperty(exports, \"useParams\", { enumerable: true, get: function () { return react_router_2.useParams; } });\nObject.defineProperty(exports, \"useRouteMatch\", { enumerable: true, get: function () { return react_router_2.useRouteMatch; } });\nObject.defineProperty(exports, \"withRouter\", { enumerable: true, get: function () { return react_router_2.withRouter; } });\nvar inheritsLoose_1 = __importDefault(__webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ \"./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\"));\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar history_1 = __webpack_require__(/*! history */ \"./node_modules/history/esm/history.js\");\nvar prop_types_1 = __importDefault(__webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\"));\nvar tiny_warning_1 = __importDefault(__webpack_require__(/*! tiny-warning */ \"./node_modules/tiny-warning/dist/tiny-warning.esm.js\"));\nvar extends_1 = __importDefault(__webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"./node_modules/@babel/runtime/helpers/esm/extends.js\"));\nvar objectWithoutPropertiesLoose_1 = __importDefault(__webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ \"./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\"));\nvar tiny_invariant_1 = __importDefault(__webpack_require__(/*! tiny-invariant */ \"./node_modules/tiny-invariant/dist/tiny-invariant.esm.js\"));\n/**\n * The public API for a <Router> that uses HTML5 history.\n */\nvar BrowserRouter = \n/*#__PURE__*/\nfunction (_React$Component) {\n    inheritsLoose_1.default(BrowserRouter, _React$Component);\n    function BrowserRouter() {\n        var _this;\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n        _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n        _this.history = history_1.createBrowserHistory(_this.props);\n        return _this;\n    }\n    var _proto = BrowserRouter.prototype;\n    _proto.render = function render() {\n        return react_1.default.createElement(react_router_1.Router, {\n            history: this.history,\n            children: this.props.children\n        });\n    };\n    return BrowserRouter;\n}(react_1.default.Component);\nexports.BrowserRouter = BrowserRouter;\nif (true) {\n    BrowserRouter.propTypes = {\n        basename: prop_types_1.default.string,\n        children: prop_types_1.default.node,\n        forceRefresh: prop_types_1.default.bool,\n        getUserConfirmation: prop_types_1.default.func,\n        keyLength: prop_types_1.default.number\n    };\n    BrowserRouter.prototype.componentDidMount = function () {\n         true ? tiny_warning_1.default(!this.props.history, \"<BrowserRouter> ignores the history prop. To use a custom history, \" + \"use `import { Router }` instead of `import { BrowserRouter as Router }`.\") : undefined;\n    };\n}\n/**\n * The public API for a <Router> that uses window.location.hash.\n */\nvar HashRouter = \n/*#__PURE__*/\nfunction (_React$Component) {\n    inheritsLoose_1.default(HashRouter, _React$Component);\n    function HashRouter() {\n        var _this;\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n        _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n        _this.history = history_1.createHashHistory(_this.props);\n        return _this;\n    }\n    var _proto = HashRouter.prototype;\n    _proto.render = function render() {\n        return react_1.default.createElement(react_router_1.Router, {\n            history: this.history,\n            children: this.props.children\n        });\n    };\n    return HashRouter;\n}(react_1.default.Component);\nexports.HashRouter = HashRouter;\nif (true) {\n    HashRouter.propTypes = {\n        basename: prop_types_1.default.string,\n        children: prop_types_1.default.node,\n        getUserConfirmation: prop_types_1.default.func,\n        hashType: prop_types_1.default.oneOf([\"hashbang\", \"noslash\", \"slash\"])\n    };\n    HashRouter.prototype.componentDidMount = function () {\n         true ? tiny_warning_1.default(!this.props.history, \"<HashRouter> ignores the history prop. To use a custom history, \" + \"use `import { Router }` instead of `import { HashRouter as Router }`.\") : undefined;\n    };\n}\nvar resolveToLocation = function resolveToLocation(to, currentLocation) {\n    return typeof to === \"function\" ? to(currentLocation) : to;\n};\nvar normalizeToLocation = function normalizeToLocation(to, currentLocation) {\n    return typeof to === \"string\" ? history_1.createLocation(to, null, null, currentLocation) : to;\n};\nvar forwardRefShim = function forwardRefShim(C) {\n    return C;\n};\nvar forwardRef = react_1.default.forwardRef;\nif (typeof forwardRef === \"undefined\") {\n    forwardRef = forwardRefShim;\n}\nfunction isModifiedEvent(event) {\n    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nvar LinkAnchor = forwardRef(function (_ref, forwardedRef) {\n    var innerRef = _ref.innerRef, navigate = _ref.navigate, _onClick = _ref.onClick, rest = objectWithoutPropertiesLoose_1.default(_ref, [\"innerRef\", \"navigate\", \"onClick\"]);\n    var target = rest.target;\n    var props = extends_1.default({}, rest, {\n        onClick: function onClick(event) {\n            try {\n                if (_onClick)\n                    _onClick(event);\n            }\n            catch (ex) {\n                event.preventDefault();\n                throw ex;\n            }\n            if (!event.defaultPrevented && // onClick prevented default\n                event.button === 0 && ( // ignore everything but left clicks\n            !target || target === \"_self\") && // let browser handle \"target=_blank\" etc.\n                !isModifiedEvent(event) // ignore clicks with modifier keys\n            ) {\n                event.preventDefault();\n                navigate();\n            }\n        }\n    }); // React 15 compat\n    if (forwardRefShim !== forwardRef) {\n        props.ref = forwardedRef || innerRef;\n    }\n    else {\n        props.ref = innerRef;\n    }\n    /* eslint-disable-next-line jsx-a11y/anchor-has-content */\n    return react_1.default.createElement(\"a\", props);\n});\nif (true) {\n    LinkAnchor.displayName = \"LinkAnchor\";\n}\n/**\n * The public API for rendering a history-aware <a>.\n */\nvar Link = forwardRef(function (_ref2, forwardedRef) {\n    var _ref2$component = _ref2.component, component = _ref2$component === void 0 ? LinkAnchor : _ref2$component, replace = _ref2.replace, to = _ref2.to, innerRef = _ref2.innerRef, rest = objectWithoutPropertiesLoose_1.default(_ref2, [\"component\", \"replace\", \"to\", \"innerRef\"]);\n    return react_1.default.createElement(react_router_1.__RouterContext.Consumer, null, function (context) {\n        !context ?  true ? tiny_invariant_1.default(false, \"You should not use <Link> outside a <Router>\") : undefined : void 0;\n        var history = context.history;\n        var location = normalizeToLocation(resolveToLocation(to, context.location), context.location);\n        var href = location ? history.createHref(location) : \"\";\n        var props = extends_1.default({}, rest, {\n            href: href,\n            navigate: function navigate() {\n                var location = resolveToLocation(to, context.location);\n                var method = replace ? history.replace : history.push;\n                method(location);\n            }\n        }); // React 15 compat\n        if (forwardRefShim !== forwardRef) {\n            props.ref = forwardedRef || innerRef;\n        }\n        else {\n            props.innerRef = innerRef;\n        }\n        return react_1.default.createElement(component, props);\n    });\n});\nexports.Link = Link;\nif (true) {\n    var toType = prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.object, prop_types_1.default.func]);\n    var refType = prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.func, prop_types_1.default.shape({\n            current: prop_types_1.default.any\n        })]);\n    Link.displayName = \"Link\";\n    Link.propTypes = {\n        innerRef: refType,\n        onClick: prop_types_1.default.func,\n        replace: prop_types_1.default.bool,\n        target: prop_types_1.default.string,\n        to: toType.isRequired\n    };\n}\nvar forwardRefShim$1 = function forwardRefShim(C) {\n    return C;\n};\nvar forwardRef$1 = react_1.default.forwardRef;\nif (typeof forwardRef$1 === \"undefined\") {\n    forwardRef$1 = forwardRefShim$1;\n}\nfunction joinClassnames() {\n    for (var _len = arguments.length, classnames = new Array(_len), _key = 0; _key < _len; _key++) {\n        classnames[_key] = arguments[_key];\n    }\n    return classnames.filter(function (i) {\n        return i;\n    }).join(\" \");\n}\n/**\n * A <Link> wrapper that knows if it's \"active\" or not.\n */\nvar NavLink = forwardRef$1(function (_ref, forwardedRef) {\n    var _ref$ariaCurrent = _ref[\"aria-current\"], ariaCurrent = _ref$ariaCurrent === void 0 ? \"page\" : _ref$ariaCurrent, _ref$activeClassName = _ref.activeClassName, activeClassName = _ref$activeClassName === void 0 ? \"active\" : _ref$activeClassName, activeStyle = _ref.activeStyle, classNameProp = _ref.className, exact = _ref.exact, isActiveProp = _ref.isActive, locationProp = _ref.location, sensitive = _ref.sensitive, strict = _ref.strict, styleProp = _ref.style, to = _ref.to, innerRef = _ref.innerRef, rest = objectWithoutPropertiesLoose_1.default(_ref, [\"aria-current\", \"activeClassName\", \"activeStyle\", \"className\", \"exact\", \"isActive\", \"location\", \"sensitive\", \"strict\", \"style\", \"to\", \"innerRef\"]);\n    return react_1.default.createElement(react_router_1.__RouterContext.Consumer, null, function (context) {\n        !context ?  true ? tiny_invariant_1.default(false, \"You should not use <NavLink> outside a <Router>\") : undefined : void 0;\n        var currentLocation = locationProp || context.location;\n        var toLocation = normalizeToLocation(resolveToLocation(to, currentLocation), currentLocation);\n        var path = toLocation.pathname; // Regex taken from: https://github.com/pillarjs/path-to-regexp/blob/master/index.js#L202\n        var escapedPath = path && path.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n        var match = escapedPath ? react_router_1.matchPath(currentLocation.pathname, {\n            path: escapedPath,\n            exact: exact,\n            sensitive: sensitive,\n            strict: strict\n        }) : null;\n        var isActive = !!(isActiveProp ? isActiveProp(match, currentLocation) : match);\n        var className = isActive ? joinClassnames(classNameProp, activeClassName) : classNameProp;\n        var style = isActive ? extends_1.default({}, styleProp, {}, activeStyle) : styleProp;\n        var props = extends_1.default({\n            \"aria-current\": isActive && ariaCurrent || null,\n            className: className,\n            style: style,\n            to: toLocation\n        }, rest); // React 15 compat\n        if (forwardRefShim$1 !== forwardRef$1) {\n            props.ref = forwardedRef || innerRef;\n        }\n        else {\n            props.innerRef = innerRef;\n        }\n        return react_1.default.createElement(Link, props);\n    });\n});\nexports.NavLink = NavLink;\nif (true) {\n    NavLink.displayName = \"NavLink\";\n    var ariaCurrentType = prop_types_1.default.oneOf([\"page\", \"step\", \"location\", \"date\", \"time\", \"true\"]);\n    NavLink.propTypes = extends_1.default({}, Link.propTypes, {\n        \"aria-current\": ariaCurrentType,\n        activeClassName: prop_types_1.default.string,\n        activeStyle: prop_types_1.default.object,\n        className: prop_types_1.default.string,\n        exact: prop_types_1.default.bool,\n        isActive: prop_types_1.default.func,\n        location: prop_types_1.default.object,\n        sensitive: prop_types_1.default.bool,\n        strict: prop_types_1.default.bool,\n        style: prop_types_1.default.object\n    });\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/react-router-dom/esm/react-router-dom.js?");

/***/ }),

/***/ "./node_modules/react-router/esm/react-router.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-router/esm/react-router.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.withRouter = exports.useRouteMatch = exports.useParams = exports.useLocation = exports.useHistory = exports.matchPath = exports.generatePath = exports.__RouterContext = exports.__HistoryContext = exports.Switch = exports.StaticRouter = exports.Router = exports.Route = exports.Redirect = exports.Prompt = exports.MemoryRouter = void 0;\nvar inheritsLoose_1 = __importDefault(__webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ \"./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\"));\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar prop_types_1 = __importDefault(__webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\"));\nvar history_1 = __webpack_require__(/*! history */ \"./node_modules/history/esm/history.js\");\nvar tiny_warning_1 = __importDefault(__webpack_require__(/*! tiny-warning */ \"./node_modules/tiny-warning/dist/tiny-warning.esm.js\"));\nvar mini_create_react_context_1 = __importDefault(__webpack_require__(/*! mini-create-react-context */ \"./node_modules/mini-create-react-context/dist/esm/index.js\"));\nvar tiny_invariant_1 = __importDefault(__webpack_require__(/*! tiny-invariant */ \"./node_modules/tiny-invariant/dist/tiny-invariant.esm.js\"));\nvar extends_1 = __importDefault(__webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"./node_modules/@babel/runtime/helpers/esm/extends.js\"));\nvar path_to_regexp_1 = __importDefault(__webpack_require__(/*! path-to-regexp */ \"./node_modules/react-router/node_modules/path-to-regexp/index.js\"));\nvar react_is_1 = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\nvar objectWithoutPropertiesLoose_1 = __importDefault(__webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ \"./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\"));\nvar hoist_non_react_statics_1 = __importDefault(__webpack_require__(/*! hoist-non-react-statics */ \"./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\"));\n// TODO: Replace with React.createContext once we can assume React 16+\nvar createNamedContext = function createNamedContext(name) {\n    var context = mini_create_react_context_1.default();\n    context.displayName = name;\n    return context;\n};\nvar historyContext = \n/*#__PURE__*/\ncreateNamedContext(\"Router-History\");\nexports.__HistoryContext = historyContext;\n// TODO: Replace with React.createContext once we can assume React 16+\nvar createNamedContext$1 = function createNamedContext(name) {\n    var context = mini_create_react_context_1.default();\n    context.displayName = name;\n    return context;\n};\nvar context = \n/*#__PURE__*/\ncreateNamedContext$1(\"Router\");\nexports.__RouterContext = context;\n/**\n * The public API for putting history on context.\n */\nvar Router = \n/*#__PURE__*/\nfunction (_React$Component) {\n    inheritsLoose_1.default(Router, _React$Component);\n    Router.computeRootMatch = function computeRootMatch(pathname) {\n        return {\n            path: \"/\",\n            url: \"/\",\n            params: {},\n            isExact: pathname === \"/\"\n        };\n    };\n    function Router(props) {\n        var _this;\n        _this = _React$Component.call(this, props) || this;\n        _this.state = {\n            location: props.history.location\n        }; // This is a bit of a hack. We have to start listening for location\n        // changes here in the constructor in case there are any <Redirect>s\n        // on the initial render. If there are, they will replace/push when\n        // they mount and since cDM fires in children before parents, we may\n        // get a new location before the <Router> is mounted.\n        _this._isMounted = false;\n        _this._pendingLocation = null;\n        if (!props.staticContext) {\n            _this.unlisten = props.history.listen(function (location) {\n                if (_this._isMounted) {\n                    _this.setState({\n                        location: location\n                    });\n                }\n                else {\n                    _this._pendingLocation = location;\n                }\n            });\n        }\n        return _this;\n    }\n    var _proto = Router.prototype;\n    _proto.componentDidMount = function componentDidMount() {\n        this._isMounted = true;\n        if (this._pendingLocation) {\n            this.setState({\n                location: this._pendingLocation\n            });\n        }\n    };\n    _proto.componentWillUnmount = function componentWillUnmount() {\n        if (this.unlisten)\n            this.unlisten();\n    };\n    _proto.render = function render() {\n        return react_1.default.createElement(context.Provider, {\n            value: {\n                history: this.props.history,\n                location: this.state.location,\n                match: Router.computeRootMatch(this.state.location.pathname),\n                staticContext: this.props.staticContext\n            }\n        }, react_1.default.createElement(historyContext.Provider, {\n            children: this.props.children || null,\n            value: this.props.history\n        }));\n    };\n    return Router;\n}(react_1.default.Component);\nexports.Router = Router;\nif (true) {\n    Router.propTypes = {\n        children: prop_types_1.default.node,\n        history: prop_types_1.default.object.isRequired,\n        staticContext: prop_types_1.default.object\n    };\n    Router.prototype.componentDidUpdate = function (prevProps) {\n         true ? tiny_warning_1.default(prevProps.history === this.props.history, \"You cannot change <Router history>\") : undefined;\n    };\n}\n/**\n * The public API for a <Router> that stores location in memory.\n */\nvar MemoryRouter = \n/*#__PURE__*/\nfunction (_React$Component) {\n    inheritsLoose_1.default(MemoryRouter, _React$Component);\n    function MemoryRouter() {\n        var _this;\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n        _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n        _this.history = history_1.createMemoryHistory(_this.props);\n        return _this;\n    }\n    var _proto = MemoryRouter.prototype;\n    _proto.render = function render() {\n        return react_1.default.createElement(Router, {\n            history: this.history,\n            children: this.props.children\n        });\n    };\n    return MemoryRouter;\n}(react_1.default.Component);\nexports.MemoryRouter = MemoryRouter;\nif (true) {\n    MemoryRouter.propTypes = {\n        initialEntries: prop_types_1.default.array,\n        initialIndex: prop_types_1.default.number,\n        getUserConfirmation: prop_types_1.default.func,\n        keyLength: prop_types_1.default.number,\n        children: prop_types_1.default.node\n    };\n    MemoryRouter.prototype.componentDidMount = function () {\n         true ? tiny_warning_1.default(!this.props.history, \"<MemoryRouter> ignores the history prop. To use a custom history, \" + \"use `import { Router }` instead of `import { MemoryRouter as Router }`.\") : undefined;\n    };\n}\nvar Lifecycle = \n/*#__PURE__*/\nfunction (_React$Component) {\n    inheritsLoose_1.default(Lifecycle, _React$Component);\n    function Lifecycle() {\n        return _React$Component.apply(this, arguments) || this;\n    }\n    var _proto = Lifecycle.prototype;\n    _proto.componentDidMount = function componentDidMount() {\n        if (this.props.onMount)\n            this.props.onMount.call(this, this);\n    };\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n        if (this.props.onUpdate)\n            this.props.onUpdate.call(this, this, prevProps);\n    };\n    _proto.componentWillUnmount = function componentWillUnmount() {\n        if (this.props.onUnmount)\n            this.props.onUnmount.call(this, this);\n    };\n    _proto.render = function render() {\n        return null;\n    };\n    return Lifecycle;\n}(react_1.default.Component);\n/**\n * The public API for prompting the user before navigating away from a screen.\n */\nfunction Prompt(_ref) {\n    var message = _ref.message, _ref$when = _ref.when, when = _ref$when === void 0 ? true : _ref$when;\n    return react_1.default.createElement(context.Consumer, null, function (context) {\n        !context ?  true ? tiny_invariant_1.default(false, \"You should not use <Prompt> outside a <Router>\") : undefined : void 0;\n        if (!when || context.staticContext)\n            return null;\n        var method = context.history.block;\n        return react_1.default.createElement(Lifecycle, {\n            onMount: function onMount(self) {\n                self.release = method(message);\n            },\n            onUpdate: function onUpdate(self, prevProps) {\n                if (prevProps.message !== message) {\n                    self.release();\n                    self.release = method(message);\n                }\n            },\n            onUnmount: function onUnmount(self) {\n                self.release();\n            },\n            message: message\n        });\n    });\n}\nexports.Prompt = Prompt;\nif (true) {\n    var messageType = prop_types_1.default.oneOfType([prop_types_1.default.func, prop_types_1.default.string]);\n    Prompt.propTypes = {\n        when: prop_types_1.default.bool,\n        message: messageType.isRequired\n    };\n}\nvar cache = {};\nvar cacheLimit = 10000;\nvar cacheCount = 0;\nfunction compilePath(path) {\n    if (cache[path])\n        return cache[path];\n    var generator = path_to_regexp_1.default.compile(path);\n    if (cacheCount < cacheLimit) {\n        cache[path] = generator;\n        cacheCount++;\n    }\n    return generator;\n}\n/**\n * Public API for generating a URL pathname from a path and parameters.\n */\nfunction generatePath(path, params) {\n    if (path === void 0) {\n        path = \"/\";\n    }\n    if (params === void 0) {\n        params = {};\n    }\n    return path === \"/\" ? path : compilePath(path)(params, {\n        pretty: true\n    });\n}\nexports.generatePath = generatePath;\n/**\n * The public API for navigating programmatically with a component.\n */\nfunction Redirect(_ref) {\n    var computedMatch = _ref.computedMatch, to = _ref.to, _ref$push = _ref.push, push = _ref$push === void 0 ? false : _ref$push;\n    return react_1.default.createElement(context.Consumer, null, function (context) {\n        !context ?  true ? tiny_invariant_1.default(false, \"You should not use <Redirect> outside a <Router>\") : undefined : void 0;\n        var history = context.history, staticContext = context.staticContext;\n        var method = push ? history.push : history.replace;\n        var location = history_1.createLocation(computedMatch ? typeof to === \"string\" ? generatePath(to, computedMatch.params) : extends_1.default({}, to, {\n            pathname: generatePath(to.pathname, computedMatch.params)\n        }) : to); // When rendering in a static context,\n        // set the new location immediately.\n        if (staticContext) {\n            method(location);\n            return null;\n        }\n        return react_1.default.createElement(Lifecycle, {\n            onMount: function onMount() {\n                method(location);\n            },\n            onUpdate: function onUpdate(self, prevProps) {\n                var prevLocation = history_1.createLocation(prevProps.to);\n                if (!history_1.locationsAreEqual(prevLocation, extends_1.default({}, location, {\n                    key: prevLocation.key\n                }))) {\n                    method(location);\n                }\n            },\n            to: to\n        });\n    });\n}\nexports.Redirect = Redirect;\nif (true) {\n    Redirect.propTypes = {\n        push: prop_types_1.default.bool,\n        from: prop_types_1.default.string,\n        to: prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.object]).isRequired\n    };\n}\nvar cache$1 = {};\nvar cacheLimit$1 = 10000;\nvar cacheCount$1 = 0;\nfunction compilePath$1(path, options) {\n    var cacheKey = \"\" + options.end + options.strict + options.sensitive;\n    var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});\n    if (pathCache[path])\n        return pathCache[path];\n    var keys = [];\n    var regexp = path_to_regexp_1.default(path, keys, options);\n    var result = {\n        regexp: regexp,\n        keys: keys\n    };\n    if (cacheCount$1 < cacheLimit$1) {\n        pathCache[path] = result;\n        cacheCount$1++;\n    }\n    return result;\n}\n/**\n * Public API for matching a URL pathname to a path.\n */\nfunction matchPath(pathname, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    if (typeof options === \"string\" || Array.isArray(options)) {\n        options = {\n            path: options\n        };\n    }\n    var _options = options, path = _options.path, _options$exact = _options.exact, exact = _options$exact === void 0 ? false : _options$exact, _options$strict = _options.strict, strict = _options$strict === void 0 ? false : _options$strict, _options$sensitive = _options.sensitive, sensitive = _options$sensitive === void 0 ? false : _options$sensitive;\n    var paths = [].concat(path);\n    return paths.reduce(function (matched, path) {\n        if (!path && path !== \"\")\n            return null;\n        if (matched)\n            return matched;\n        var _compilePath = compilePath$1(path, {\n            end: exact,\n            strict: strict,\n            sensitive: sensitive\n        }), regexp = _compilePath.regexp, keys = _compilePath.keys;\n        var match = regexp.exec(pathname);\n        if (!match)\n            return null;\n        var url = match[0], values = match.slice(1);\n        var isExact = pathname === url;\n        if (exact && !isExact)\n            return null;\n        return {\n            path: path,\n            // the path used to match\n            url: path === \"/\" && url === \"\" ? \"/\" : url,\n            // the matched portion of the URL\n            isExact: isExact,\n            // whether or not we matched exactly\n            params: keys.reduce(function (memo, key, index) {\n                memo[key.name] = values[index];\n                return memo;\n            }, {})\n        };\n    }, null);\n}\nexports.matchPath = matchPath;\nfunction isEmptyChildren(children) {\n    return react_1.default.Children.count(children) === 0;\n}\nfunction evalChildrenDev(children, props, path) {\n    var value = children(props);\n     true ? tiny_warning_1.default(value !== undefined, \"You returned `undefined` from the `children` function of \" + (\"<Route\" + (path ? \" path=\\\"\" + path + \"\\\"\" : \"\") + \">, but you \") + \"should have returned a React element or `null`\") : undefined;\n    return value || null;\n}\n/**\n * The public API for matching a single path and rendering.\n */\nvar Route = \n/*#__PURE__*/\nfunction (_React$Component) {\n    inheritsLoose_1.default(Route, _React$Component);\n    function Route() {\n        return _React$Component.apply(this, arguments) || this;\n    }\n    var _proto = Route.prototype;\n    _proto.render = function render() {\n        var _this = this;\n        return react_1.default.createElement(context.Consumer, null, function (context$1) {\n            !context$1 ?  true ? tiny_invariant_1.default(false, \"You should not use <Route> outside a <Router>\") : undefined : void 0;\n            var location = _this.props.location || context$1.location;\n            var match = _this.props.computedMatch ? _this.props.computedMatch // <Switch> already computed the match for us\n                : _this.props.path ? matchPath(location.pathname, _this.props) : context$1.match;\n            var props = extends_1.default({}, context$1, {\n                location: location,\n                match: match\n            });\n            var _this$props = _this.props, children = _this$props.children, component = _this$props.component, render = _this$props.render; // Preact uses an empty array as children by\n            // default, so use null if that's the case.\n            if (Array.isArray(children) && children.length === 0) {\n                children = null;\n            }\n            return react_1.default.createElement(context.Provider, {\n                value: props\n            }, props.match ? children ? typeof children === \"function\" ?  true ? evalChildrenDev(children, props, _this.props.path) : undefined : children : component ? react_1.default.createElement(component, props) : render ? render(props) : null : typeof children === \"function\" ?  true ? evalChildrenDev(children, props, _this.props.path) : undefined : null);\n        });\n    };\n    return Route;\n}(react_1.default.Component);\nexports.Route = Route;\nif (true) {\n    Route.propTypes = {\n        children: prop_types_1.default.oneOfType([prop_types_1.default.func, prop_types_1.default.node]),\n        component: function component(props, propName) {\n            if (props[propName] && !react_is_1.isValidElementType(props[propName])) {\n                return new Error(\"Invalid prop 'component' supplied to 'Route': the prop is not a valid React component\");\n            }\n        },\n        exact: prop_types_1.default.bool,\n        location: prop_types_1.default.object,\n        path: prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.arrayOf(prop_types_1.default.string)]),\n        render: prop_types_1.default.func,\n        sensitive: prop_types_1.default.bool,\n        strict: prop_types_1.default.bool\n    };\n    Route.prototype.componentDidMount = function () {\n         true ? tiny_warning_1.default(!(this.props.children && !isEmptyChildren(this.props.children) && this.props.component), \"You should not use <Route component> and <Route children> in the same route; <Route component> will be ignored\") : undefined;\n         true ? tiny_warning_1.default(!(this.props.children && !isEmptyChildren(this.props.children) && this.props.render), \"You should not use <Route render> and <Route children> in the same route; <Route render> will be ignored\") : undefined;\n         true ? tiny_warning_1.default(!(this.props.component && this.props.render), \"You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored\") : undefined;\n    };\n    Route.prototype.componentDidUpdate = function (prevProps) {\n         true ? tiny_warning_1.default(!(this.props.location && !prevProps.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no \"location\" prop and then provided one on a subsequent render.') : undefined;\n         true ? tiny_warning_1.default(!(!this.props.location && prevProps.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a \"location\" prop initially but omitted it on a subsequent render.') : undefined;\n    };\n}\nfunction addLeadingSlash(path) {\n    return path.charAt(0) === \"/\" ? path : \"/\" + path;\n}\nfunction addBasename(basename, location) {\n    if (!basename)\n        return location;\n    return extends_1.default({}, location, {\n        pathname: addLeadingSlash(basename) + location.pathname\n    });\n}\nfunction stripBasename(basename, location) {\n    if (!basename)\n        return location;\n    var base = addLeadingSlash(basename);\n    if (location.pathname.indexOf(base) !== 0)\n        return location;\n    return extends_1.default({}, location, {\n        pathname: location.pathname.substr(base.length)\n    });\n}\nfunction createURL(location) {\n    return typeof location === \"string\" ? location : history_1.createPath(location);\n}\nfunction staticHandler(methodName) {\n    return function () {\n         true ? tiny_invariant_1.default(false, \"You cannot %s with <StaticRouter>\", methodName) : undefined;\n    };\n}\nfunction noop() { }\n/**\n * The public top-level API for a \"static\" <Router>, so-called because it\n * can't actually change the current location. Instead, it just records\n * location changes in a context object. Useful mainly in testing and\n * server-rendering scenarios.\n */\nvar StaticRouter = \n/*#__PURE__*/\nfunction (_React$Component) {\n    inheritsLoose_1.default(StaticRouter, _React$Component);\n    function StaticRouter() {\n        var _this;\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n        _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n        _this.handlePush = function (location) {\n            return _this.navigateTo(location, \"PUSH\");\n        };\n        _this.handleReplace = function (location) {\n            return _this.navigateTo(location, \"REPLACE\");\n        };\n        _this.handleListen = function () {\n            return noop;\n        };\n        _this.handleBlock = function () {\n            return noop;\n        };\n        return _this;\n    }\n    var _proto = StaticRouter.prototype;\n    _proto.navigateTo = function navigateTo(location, action) {\n        var _this$props = this.props, _this$props$basename = _this$props.basename, basename = _this$props$basename === void 0 ? \"\" : _this$props$basename, _this$props$context = _this$props.context, context = _this$props$context === void 0 ? {} : _this$props$context;\n        context.action = action;\n        context.location = addBasename(basename, history_1.createLocation(location));\n        context.url = createURL(context.location);\n    };\n    _proto.render = function render() {\n        var _this$props2 = this.props, _this$props2$basename = _this$props2.basename, basename = _this$props2$basename === void 0 ? \"\" : _this$props2$basename, _this$props2$context = _this$props2.context, context = _this$props2$context === void 0 ? {} : _this$props2$context, _this$props2$location = _this$props2.location, location = _this$props2$location === void 0 ? \"/\" : _this$props2$location, rest = objectWithoutPropertiesLoose_1.default(_this$props2, [\"basename\", \"context\", \"location\"]);\n        var history = {\n            createHref: function createHref(path) {\n                return addLeadingSlash(basename + createURL(path));\n            },\n            action: \"POP\",\n            location: stripBasename(basename, history_1.createLocation(location)),\n            push: this.handlePush,\n            replace: this.handleReplace,\n            go: staticHandler(\"go\"),\n            goBack: staticHandler(\"goBack\"),\n            goForward: staticHandler(\"goForward\"),\n            listen: this.handleListen,\n            block: this.handleBlock\n        };\n        return react_1.default.createElement(Router, extends_1.default({}, rest, {\n            history: history,\n            staticContext: context\n        }));\n    };\n    return StaticRouter;\n}(react_1.default.Component);\nexports.StaticRouter = StaticRouter;\nif (true) {\n    StaticRouter.propTypes = {\n        basename: prop_types_1.default.string,\n        context: prop_types_1.default.object,\n        location: prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.object])\n    };\n    StaticRouter.prototype.componentDidMount = function () {\n         true ? tiny_warning_1.default(!this.props.history, \"<StaticRouter> ignores the history prop. To use a custom history, \" + \"use `import { Router }` instead of `import { StaticRouter as Router }`.\") : undefined;\n    };\n}\n/**\n * The public API for rendering the first <Route> that matches.\n */\nvar Switch = \n/*#__PURE__*/\nfunction (_React$Component) {\n    inheritsLoose_1.default(Switch, _React$Component);\n    function Switch() {\n        return _React$Component.apply(this, arguments) || this;\n    }\n    var _proto = Switch.prototype;\n    _proto.render = function render() {\n        var _this = this;\n        return react_1.default.createElement(context.Consumer, null, function (context) {\n            !context ?  true ? tiny_invariant_1.default(false, \"You should not use <Switch> outside a <Router>\") : undefined : void 0;\n            var location = _this.props.location || context.location;\n            var element, match; // We use React.Children.forEach instead of React.Children.toArray().find()\n            // here because toArray adds keys to all child elements and we do not want\n            // to trigger an unmount/remount for two <Route>s that render the same\n            // component at different URLs.\n            react_1.default.Children.forEach(_this.props.children, function (child) {\n                if (match == null && react_1.default.isValidElement(child)) {\n                    element = child;\n                    var path = child.props.path || child.props.from;\n                    match = path ? matchPath(location.pathname, extends_1.default({}, child.props, {\n                        path: path\n                    })) : context.match;\n                }\n            });\n            return match ? react_1.default.cloneElement(element, {\n                location: location,\n                computedMatch: match\n            }) : null;\n        });\n    };\n    return Switch;\n}(react_1.default.Component);\nexports.Switch = Switch;\nif (true) {\n    Switch.propTypes = {\n        children: prop_types_1.default.node,\n        location: prop_types_1.default.object\n    };\n    Switch.prototype.componentDidUpdate = function (prevProps) {\n         true ? tiny_warning_1.default(!(this.props.location && !prevProps.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no \"location\" prop and then provided one on a subsequent render.') : undefined;\n         true ? tiny_warning_1.default(!(!this.props.location && prevProps.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a \"location\" prop initially but omitted it on a subsequent render.') : undefined;\n    };\n}\n/**\n * A public higher-order component to access the imperative API\n */\nfunction withRouter(Component) {\n    var displayName = \"withRouter(\" + (Component.displayName || Component.name) + \")\";\n    var C = function C(props) {\n        var wrappedComponentRef = props.wrappedComponentRef, remainingProps = objectWithoutPropertiesLoose_1.default(props, [\"wrappedComponentRef\"]);\n        return react_1.default.createElement(context.Consumer, null, function (context) {\n            !context ?  true ? tiny_invariant_1.default(false, \"You should not use <\" + displayName + \" /> outside a <Router>\") : undefined : void 0;\n            return react_1.default.createElement(Component, extends_1.default({}, remainingProps, context, {\n                ref: wrappedComponentRef\n            }));\n        });\n    };\n    C.displayName = displayName;\n    C.WrappedComponent = Component;\n    if (true) {\n        C.propTypes = {\n            wrappedComponentRef: prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.func, prop_types_1.default.object])\n        };\n    }\n    return hoist_non_react_statics_1.default(C, Component);\n}\nexports.withRouter = withRouter;\nvar useContext = react_1.default.useContext;\nfunction useHistory() {\n    if (true) {\n        !(typeof useContext === \"function\") ?  true ? tiny_invariant_1.default(false, \"You must use React >= 16.8 in order to use useHistory()\") : undefined : void 0;\n    }\n    return useContext(historyContext);\n}\nexports.useHistory = useHistory;\nfunction useLocation() {\n    if (true) {\n        !(typeof useContext === \"function\") ?  true ? tiny_invariant_1.default(false, \"You must use React >= 16.8 in order to use useLocation()\") : undefined : void 0;\n    }\n    return useContext(context).location;\n}\nexports.useLocation = useLocation;\nfunction useParams() {\n    if (true) {\n        !(typeof useContext === \"function\") ?  true ? tiny_invariant_1.default(false, \"You must use React >= 16.8 in order to use useParams()\") : undefined : void 0;\n    }\n    var match = useContext(context).match;\n    return match ? match.params : {};\n}\nexports.useParams = useParams;\nfunction useRouteMatch(path) {\n    if (true) {\n        !(typeof useContext === \"function\") ?  true ? tiny_invariant_1.default(false, \"You must use React >= 16.8 in order to use useRouteMatch()\") : undefined : void 0;\n    }\n    var location = useLocation();\n    var match = useContext(context).match;\n    return path ? matchPath(location.pathname, path) : match;\n}\nexports.useRouteMatch = useRouteMatch;\nif (true) {\n    if (typeof window !== \"undefined\") {\n        var global = window;\n        var key = \"__react_router_build__\";\n        var buildNames = {\n            cjs: \"CommonJS\",\n            esm: \"ES modules\",\n            umd: \"UMD\"\n        };\n        if (global[key] && global[key] !== \"esm\") {\n            var initialBuildName = buildNames[global[key]];\n            var secondaryBuildName = buildNames[\"esm\"]; // TODO: Add link to article that explains in detail how to avoid\n            // loading 2 different builds.\n            throw new Error(\"You are loading the \" + secondaryBuildName + \" build of React Router \" + (\"on a page that is already running the \" + initialBuildName + \" \") + \"build, so things won't work right.\");\n        }\n        global[key] = \"esm\";\n    }\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/react-router/esm/react-router.js?");

/***/ }),

/***/ "./node_modules/react-router/node_modules/isarray/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-router/node_modules/isarray/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = Array.isArray || function (arr) {\n    return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack:///./node_modules/react-router/node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/react-router/node_modules/path-to-regexp/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-router/node_modules/path-to-regexp/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar isarray = __webpack_require__(/*! isarray */ \"./node_modules/react-router/node_modules/isarray/index.js\");\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp;\nmodule.exports.parse = parse;\nmodule.exports.compile = compile;\nmodule.exports.tokensToFunction = tokensToFunction;\nmodule.exports.tokensToRegExp = tokensToRegExp;\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n    // Match escaped characters that would otherwise appear in future matches.\n    // This allows the user to escape special characters that won't transform.\n    '(\\\\\\\\.)',\n    // Match Express-style parameters and un-named parameters with a prefix\n    // and optional suffixes. Matches appear as:\n    //\n    // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n    // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n    // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n    '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g');\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse(str, options) {\n    var tokens = [];\n    var key = 0;\n    var index = 0;\n    var path = '';\n    var defaultDelimiter = options && options.delimiter || '/';\n    var res;\n    while ((res = PATH_REGEXP.exec(str)) != null) {\n        var m = res[0];\n        var escaped = res[1];\n        var offset = res.index;\n        path += str.slice(index, offset);\n        index = offset + m.length;\n        // Ignore already escaped sequences.\n        if (escaped) {\n            path += escaped[1];\n            continue;\n        }\n        var next = str[index];\n        var prefix = res[2];\n        var name = res[3];\n        var capture = res[4];\n        var group = res[5];\n        var modifier = res[6];\n        var asterisk = res[7];\n        // Push the current path onto the tokens.\n        if (path) {\n            tokens.push(path);\n            path = '';\n        }\n        var partial = prefix != null && next != null && next !== prefix;\n        var repeat = modifier === '+' || modifier === '*';\n        var optional = modifier === '?' || modifier === '*';\n        var delimiter = res[2] || defaultDelimiter;\n        var pattern = capture || group;\n        tokens.push({\n            name: name || key++,\n            prefix: prefix || '',\n            delimiter: delimiter,\n            optional: optional,\n            repeat: repeat,\n            partial: partial,\n            asterisk: !!asterisk,\n            pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n        });\n    }\n    // Match any characters still remaining.\n    if (index < str.length) {\n        path += str.substr(index);\n    }\n    // If the path exists, push it onto the end.\n    if (path) {\n        tokens.push(path);\n    }\n    return tokens;\n}\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty(str) {\n    return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n        return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n    });\n}\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk(str) {\n    return encodeURI(str).replace(/[?#]/g, function (c) {\n        return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n    });\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction(tokens, options) {\n    // Compile all the tokens into regexps.\n    var matches = new Array(tokens.length);\n    // Compile all the patterns before compilation.\n    for (var i = 0; i < tokens.length; i++) {\n        if (typeof tokens[i] === 'object') {\n            matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options));\n        }\n    }\n    return function (obj, opts) {\n        var path = '';\n        var data = obj || {};\n        var options = opts || {};\n        var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === 'string') {\n                path += token;\n                continue;\n            }\n            var value = data[token.name];\n            var segment;\n            if (value == null) {\n                if (token.optional) {\n                    // Prepend partial segment prefixes.\n                    if (token.partial) {\n                        path += token.prefix;\n                    }\n                    continue;\n                }\n                else {\n                    throw new TypeError('Expected \"' + token.name + '\" to be defined');\n                }\n            }\n            if (isarray(value)) {\n                if (!token.repeat) {\n                    throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`');\n                }\n                if (value.length === 0) {\n                    if (token.optional) {\n                        continue;\n                    }\n                    else {\n                        throw new TypeError('Expected \"' + token.name + '\" to not be empty');\n                    }\n                }\n                for (var j = 0; j < value.length; j++) {\n                    segment = encode(value[j]);\n                    if (!matches[i].test(segment)) {\n                        throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`');\n                    }\n                    path += (j === 0 ? token.prefix : token.delimiter) + segment;\n                }\n                continue;\n            }\n            segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n            if (!matches[i].test(segment)) {\n                throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"');\n            }\n            path += token.prefix + segment;\n        }\n        return path;\n    };\n}\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1');\n}\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup(group) {\n    return group.replace(/([=!:$\\/()])/g, '\\\\$1');\n}\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys(re, keys) {\n    re.keys = keys;\n    return re;\n}\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags(options) {\n    return options && options.sensitive ? '' : 'i';\n}\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp(path, keys) {\n    // Use a negative lookahead to match only capturing groups.\n    var groups = path.source.match(/\\((?!\\?)/g);\n    if (groups) {\n        for (var i = 0; i < groups.length; i++) {\n            keys.push({\n                name: i,\n                prefix: null,\n                delimiter: null,\n                optional: false,\n                repeat: false,\n                partial: false,\n                asterisk: false,\n                pattern: null\n            });\n        }\n    }\n    return attachKeys(path, keys);\n}\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp(path, keys, options) {\n    var parts = [];\n    for (var i = 0; i < path.length; i++) {\n        parts.push(pathToRegexp(path[i], keys, options).source);\n    }\n    var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n    return attachKeys(regexp, keys);\n}\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegExp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp(tokens, keys, options) {\n    if (!isarray(keys)) {\n        options = /** @type {!Object} */ (keys || options);\n        keys = [];\n    }\n    options = options || {};\n    var strict = options.strict;\n    var end = options.end !== false;\n    var route = '';\n    // Iterate over the tokens and create our regexp string.\n    for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n        if (typeof token === 'string') {\n            route += escapeString(token);\n        }\n        else {\n            var prefix = escapeString(token.prefix);\n            var capture = '(?:' + token.pattern + ')';\n            keys.push(token);\n            if (token.repeat) {\n                capture += '(?:' + prefix + capture + ')*';\n            }\n            if (token.optional) {\n                if (!token.partial) {\n                    capture = '(?:' + prefix + '(' + capture + '))?';\n                }\n                else {\n                    capture = prefix + '(' + capture + ')?';\n                }\n            }\n            else {\n                capture = prefix + '(' + capture + ')';\n            }\n            route += capture;\n        }\n    }\n    var delimiter = escapeString(options.delimiter || '/');\n    var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\n    // In non-strict mode we allow a slash at the end of match. If the path to\n    // match already ends with a slash, we remove it for consistency. The slash\n    // is valid at the end of a path match, not in the middle. This is important\n    // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n    if (!strict) {\n        route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n    }\n    if (end) {\n        route += '$';\n    }\n    else {\n        // In non-ending mode, we need the capturing groups to match as much as\n        // possible by using a positive lookahead to the end or next path segment.\n        route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n    }\n    return attachKeys(new RegExp('^' + route, flags(options)), keys);\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp(path, keys, options) {\n    if (!isarray(keys)) {\n        options = /** @type {!Object} */ (keys || options);\n        keys = [];\n    }\n    options = options || {};\n    if (path instanceof RegExp) {\n        return regexpToRegexp(path, /** @type {!Array} */ (keys));\n    }\n    if (isarray(path)) {\n        return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options);\n    }\n    return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options);\n}\n\n\n//# sourceURL=webpack:///./node_modules/react-router/node_modules/path-to-regexp/index.js?");

/***/ }),

/***/ "./node_modules/resolve-pathname/esm/resolve-pathname.js":
/*!***************************************************************!*\
  !*** ./node_modules/resolve-pathname/esm/resolve-pathname.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isAbsolute(pathname) {\n    return pathname.charAt(0) === '/';\n}\n// About 1.5x faster than the two-arg version of Array#splice()\nfunction spliceOne(list, index) {\n    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\n        list[i] = list[k];\n    }\n    list.pop();\n}\n// This implementation is based heavily on node's url.parse\nfunction resolvePathname(to, from) {\n    if (from === undefined)\n        from = '';\n    var toParts = (to && to.split('/')) || [];\n    var fromParts = (from && from.split('/')) || [];\n    var isToAbs = to && isAbsolute(to);\n    var isFromAbs = from && isAbsolute(from);\n    var mustEndAbs = isToAbs || isFromAbs;\n    if (to && isAbsolute(to)) {\n        // to is absolute\n        fromParts = toParts;\n    }\n    else if (toParts.length) {\n        // to is relative, drop the filename\n        fromParts.pop();\n        fromParts = fromParts.concat(toParts);\n    }\n    if (!fromParts.length)\n        return '/';\n    var hasTrailingSlash;\n    if (fromParts.length) {\n        var last = fromParts[fromParts.length - 1];\n        hasTrailingSlash = last === '.' || last === '..' || last === '';\n    }\n    else {\n        hasTrailingSlash = false;\n    }\n    var up = 0;\n    for (var i = fromParts.length; i >= 0; i--) {\n        var part = fromParts[i];\n        if (part === '.') {\n            spliceOne(fromParts, i);\n        }\n        else if (part === '..') {\n            spliceOne(fromParts, i);\n            up++;\n        }\n        else if (up) {\n            spliceOne(fromParts, i);\n            up--;\n        }\n    }\n    if (!mustEndAbs)\n        for (; up--; up)\n            fromParts.unshift('..');\n    if (mustEndAbs &&\n        fromParts[0] !== '' &&\n        (!fromParts[0] || !isAbsolute(fromParts[0])))\n        fromParts.unshift('');\n    var result = fromParts.join('/');\n    if (hasTrailingSlash && result.substr(-1) !== '/')\n        result += '/';\n    return result;\n}\nexports.default = resolvePathname;\n\n\n//# sourceURL=webpack:///./node_modules/resolve-pathname/esm/resolve-pathname.js?");

/***/ }),

/***/ "./node_modules/tiny-invariant/dist/tiny-invariant.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/tiny-invariant/dist/tiny-invariant.esm.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar isProduction = \"development\" === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    throw new Error(prefix + \": \" + (message || ''));\n}\nexports.default = invariant;\n\n\n//# sourceURL=webpack:///./node_modules/tiny-invariant/dist/tiny-invariant.esm.js?");

/***/ }),

/***/ "./node_modules/value-equal/esm/value-equal.js":
/*!*****************************************************!*\
  !*** ./node_modules/value-equal/esm/value-equal.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction valueOf(obj) {\n    return obj.valueOf ? obj.valueOf() : Object.prototype.valueOf.call(obj);\n}\nfunction valueEqual(a, b) {\n    // Test for strict equality first.\n    if (a === b)\n        return true;\n    // Otherwise, if either of them == null they are not equal.\n    if (a == null || b == null)\n        return false;\n    if (Array.isArray(a)) {\n        return (Array.isArray(b) &&\n            a.length === b.length &&\n            a.every(function (item, index) {\n                return valueEqual(item, b[index]);\n            }));\n    }\n    if (typeof a === 'object' || typeof b === 'object') {\n        var aValue = valueOf(a);\n        var bValue = valueOf(b);\n        if (aValue !== a || bValue !== b)\n            return valueEqual(aValue, bValue);\n        return Object.keys(Object.assign({}, a, b)).every(function (key) {\n            return valueEqual(a[key], b[key]);\n        });\n    }\n    return false;\n}\nexports.default = valueEqual;\n\n\n//# sourceURL=webpack:///./node_modules/value-equal/esm/value-equal.js?");

/***/ }),

/***/ "./src/App.tsx":
/*!*********************!*\
  !*** ./src/App.tsx ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.App = void 0;\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n__webpack_require__(/*! ./main.global.less */ \"./src/main.global.less\");\nvar root_1 = __webpack_require__(/*! react-hot-loader/root */ \"./node_modules/react-hot-loader/root.js\");\nvar Layout_1 = __webpack_require__(/*! ./shared/Layout */ \"./src/shared/Layout/index.ts\");\nvar Header_1 = __webpack_require__(/*! ./shared/Header */ \"./src/shared/Header/index.ts\");\nvar Content_1 = __webpack_require__(/*! ./shared/Content */ \"./src/shared/Content/index.ts\");\nvar CardsList_1 = __webpack_require__(/*! ./shared/CardsList */ \"./src/shared/CardsList/index.ts\");\nvar userContext_1 = __webpack_require__(/*! ./shared/context/userContext */ \"./src/shared/context/userContext.tsx\");\nvar postsContext_1 = __webpack_require__(/*! ./shared/context/postsContext */ \"./src/shared/context/postsContext.tsx\");\nvar redux_1 = __webpack_require__(/*! redux */ \"./node_modules/redux/es/redux.js\");\nvar react_redux_1 = __webpack_require__(/*! react-redux */ \"./node_modules/react-redux/es/index.js\");\nvar redux_devtools_extension_1 = __webpack_require__(/*! redux-devtools-extension */ \"./node_modules/redux-devtools-extension/index.js\");\nvar reducer_1 = __webpack_require__(/*! ./store/reducer */ \"./src/store/reducer.ts\");\nvar redux_thunk_1 = __importDefault(__webpack_require__(/*! redux-thunk */ \"./node_modules/redux-thunk/es/index.js\"));\nvar react_router_dom_1 = __webpack_require__(/*! react-router-dom */ \"./node_modules/react-router-dom/esm/react-router-dom.js\");\nvar Post_1 = __webpack_require__(/*! ./shared/Post */ \"./src/shared/Post/index.ts\");\nvar store = redux_1.createStore(reducer_1.rootReducer, redux_devtools_extension_1.composeWithDevTools(redux_1.applyMiddleware(redux_thunk_1.default)));\nfunction AppComponent() {\n    var _a = react_1.useState(false), mounted = _a[0], setMounted = _a[1];\n    react_1.useEffect(function () {\n        setMounted(true);\n    }, []);\n    return (react_1.default.createElement(react_redux_1.Provider, { store: store }, mounted && (react_1.default.createElement(react_router_dom_1.BrowserRouter, null,\n        react_1.default.createElement(userContext_1.UserContextProvider, null,\n            react_1.default.createElement(Layout_1.Layout, null,\n                react_1.default.createElement(Header_1.Header, null),\n                react_1.default.createElement(Content_1.Content, null,\n                    react_1.default.createElement(postsContext_1.PostsContextProvider, null,\n                        react_1.default.createElement(react_router_dom_1.Switch, null,\n                            react_1.default.createElement(react_router_dom_1.Redirect, { exact: true, from: \"/\", to: \"/posts\" }),\n                            react_1.default.createElement(react_router_dom_1.Redirect, { from: \"/auth\", to: \"/posts\" }),\n                            react_1.default.createElement(react_router_dom_1.Route, { path: \"/posts\" },\n                                react_1.default.createElement(CardsList_1.CardsList, null),\n                                react_1.default.createElement(react_router_dom_1.Route, { path: \"/posts/:id\" },\n                                    react_1.default.createElement(Post_1.Post, null))),\n                            react_1.default.createElement(react_router_dom_1.Route, { path: \"*\", exact: true },\n                                react_1.default.createElement(\"h1\", { style: { textAlign: 'center', padding: '50px 0' } }, \"404 - \\u0441\\u0442\\u0440\\u0430\\u043D\\u0438\\u0446\\u0430 \\u043D\\u0435 \\u043D\\u0430\\u0439\\u0434\\u0435\\u043D\\u0430\")))))))))));\n}\nexports.App = root_1.hot(function () { return react_1.default.createElement(AppComponent, null); });\n\n\n//# sourceURL=webpack:///./src/App.tsx?");

/***/ }),

/***/ "./src/client/index.jsx":
/*!******************************!*\
  !*** ./src/client/index.jsx ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar React = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar ReactDOM = __importStar(__webpack_require__(/*! react-dom */ \"./node_modules/@hot-loader/react-dom/index.js\"));\nvar App_1 = __webpack_require__(/*! ../App */ \"./src/App.tsx\");\nwindow.addEventListener('load', function () {\n    ReactDOM.hydrate(React.createElement(App_1.App, null), document.getElementById('react_root'));\n});\n\n\n//# sourceURL=webpack:///./src/client/index.jsx?");

/***/ }),

/***/ "./src/shared/CardsList/Card/TextContent/TextContent.tsx":
/*!***************************************************************!*\
  !*** ./src/shared/CardsList/Card/TextContent/TextContent.tsx ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextContent = void 0;\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar textcontent_less_1 = __importDefault(__webpack_require__(/*! ./textcontent.less */ \"./src/shared/CardsList/Card/TextContent/textcontent.less\"));\nvar formatDate_1 = __webpack_require__(/*! ../../../../utils/js/formatDate */ \"./src/utils/js/formatDate.js\");\nvar react_router_dom_1 = __webpack_require__(/*! react-router-dom */ \"./node_modules/react-router-dom/esm/react-router-dom.js\");\nfunction TextContent(_a) {\n    // const [isModalOpened, setIsModalOpened] = useState(false);\n    var username = _a.username, title = _a.title, createDate = _a.createDate, postId = _a.postId, icon = _a.icon;\n    var authorLink = \"https://reddit.com/user/\" + username;\n    return (react_1.default.createElement(\"div\", { className: textcontent_less_1.default.textContent },\n        react_1.default.createElement(\"div\", { className: textcontent_less_1.default.metaData },\n            react_1.default.createElement(\"div\", { className: textcontent_less_1.default.userLink },\n                react_1.default.createElement(\"img\", { className: textcontent_less_1.default.avatar, src: icon.icon_img, alt: \"avatar\" }),\n                react_1.default.createElement(\"a\", { href: authorLink, target: \"_blank\", className: textcontent_less_1.default.username }, username)),\n            react_1.default.createElement(\"span\", { className: textcontent_less_1.default.createdAt },\n                react_1.default.createElement(\"span\", { className: textcontent_less_1.default.publishedLabel }, \"\\u043E\\u043F\\u0443\\u0431\\u043B\\u0438\\u043A\\u043E\\u0432\\u0430\\u043D\\u043E \"),\n                formatDate_1.formatDate(createDate * 1000))),\n        react_1.default.createElement(\"h2\", { className: textcontent_less_1.default.title },\n            react_1.default.createElement(react_router_dom_1.Link, { to: \"/posts/\" + postId, className: textcontent_less_1.default.postLink }, title))));\n}\nexports.TextContent = TextContent;\n\n\n//# sourceURL=webpack:///./src/shared/CardsList/Card/TextContent/TextContent.tsx?");

/***/ }),

/***/ "./src/shared/CardsList/Card/TextContent/index.ts":
/*!********************************************************!*\
  !*** ./src/shared/CardsList/Card/TextContent/index.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./TextContent */ \"./src/shared/CardsList/Card/TextContent/TextContent.tsx\"), exports);\n\n\n//# sourceURL=webpack:///./src/shared/CardsList/Card/TextContent/index.ts?");

/***/ }),

/***/ "./src/shared/CardsList/CardsList.tsx":
/*!********************************************!*\
  !*** ./src/shared/CardsList/CardsList.tsx ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CardsList = void 0;\nvar axios_1 = __importDefault(__webpack_require__(/*! axios */ \"./node_modules/axios/index.js\"));\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar cardslist_less_1 = __importDefault(__webpack_require__(/*! ./cardslist.less */ \"./src/shared/CardsList/cardslist.less\"));\nvar Card_1 = __webpack_require__(/*! ./Card */ \"./src/shared/CardsList/Card/index.ts\");\nvar generateRandomIndex_1 = __webpack_require__(/*! ../../utils/react/generateRandomIndex */ \"./src/utils/react/generateRandomIndex.ts\");\nfunction CardsList() {\n    var _a = react_1.useState([]), posts = _a[0], setPosts = _a[1];\n    var _b = react_1.useState(false), loading = _b[0], setLoading = _b[1];\n    var _c = react_1.useState(''), errorLoading = _c[0], setErrorLoading = _c[1];\n    var _d = react_1.useState(''), nextAfter = _d[0], setNextAfter = _d[1];\n    var _e = react_1.useState(0), counter = _e[0], setCounter = _e[1];\n    var _f = react_1.useState(false), more = _f[0], setMore = _f[1];\n    var bottomOfList = react_1.useRef(null);\n    react_1.useEffect(function () {\n        function load() {\n            return __awaiter(this, void 0, void 0, function () {\n                var _a, after, children_1, error_1;\n                return __generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            setLoading(true);\n                            setErrorLoading('');\n                            _b.label = 1;\n                        case 1:\n                            _b.trys.push([1, 3, , 4]);\n                            return [4 /*yield*/, axios_1.default.get('https://www.reddit.com/r/popular/best.json?sr_detail=true&limit=10', {\n                                    params: {\n                                        limit: 10,\n                                        after: nextAfter,\n                                    }\n                                })];\n                        case 2:\n                            _a = (_b.sent()).data.data, after = _a.after, children_1 = _a.children;\n                            setNextAfter(after);\n                            setPosts(function (prevChildren) { return prevChildren.concat.apply(prevChildren, children_1); });\n                            return [3 /*break*/, 4];\n                        case 3:\n                            error_1 = _b.sent();\n                            setErrorLoading(String(error_1));\n                            return [3 /*break*/, 4];\n                        case 4:\n                            setLoading(false);\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        }\n        var observer = new IntersectionObserver(function (entries) {\n            if (entries[0].isIntersecting) {\n                if (counter < 2) {\n                    load();\n                    setCounter(counter + 1);\n                }\n                else {\n                    setMore(true);\n                }\n            }\n        }, {\n            rootMargin: '10px',\n        });\n        if (bottomOfList.current) {\n            observer.observe(bottomOfList.current);\n        }\n        return function () {\n            if (bottomOfList.current) {\n                observer.unobserve(bottomOfList.current);\n            }\n        };\n    }, [bottomOfList.current, nextAfter, more]);\n    function showMore() {\n        setCounter(0);\n        setMore(false);\n    }\n    return (react_1.default.createElement(\"ul\", { className: cardslist_less_1.default.cardList },\n        posts.length === 0 && !loading && !errorLoading && (react_1.default.createElement(\"div\", { style: { textAlign: 'center' } }, \"\\u041D\\u0435\\u0442 \\u043D\\u0438 \\u043E\\u0434\\u043D\\u043E\\u0433\\u043E \\u043F\\u043E\\u0441\\u0442\\u0430\")),\n        posts.map(function (post) { return (react_1.default.createElement(Card_1.Card, { post: post, key: generateRandomIndex_1.generateRandomString() })); }),\n        loading && (react_1.default.createElement(\"div\", { style: { textAlign: 'center' } }, \"\\u0417\\u0430\\u0433\\u0440\\u0443\\u0437\\u043A\\u0430...\")),\n        errorLoading && (react_1.default.createElement(\"div\", { role: \"alert\", style: { textAlign: 'center' } }, errorLoading)),\n        react_1.default.createElement(\"button\", { onClick: showMore, className: cardslist_less_1.default.moreBtn, style: more ? { display: 'block' } : { display: 'none' } }, \"\\u0417\\u0430\\u0433\\u0440\\u0443\\u0437\\u0438\\u0442\\u044C \\u0435\\u0449\\u0451\"),\n        react_1.default.createElement(\"div\", { ref: bottomOfList })));\n}\nexports.CardsList = CardsList;\n\n\n//# sourceURL=webpack:///./src/shared/CardsList/CardsList.tsx?");

/***/ }),

/***/ "./src/shared/CardsList/index.ts":
/*!***************************************!*\
  !*** ./src/shared/CardsList/index.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./CardsList */ \"./src/shared/CardsList/CardsList.tsx\"), exports);\n\n\n//# sourceURL=webpack:///./src/shared/CardsList/index.ts?");

/***/ }),

/***/ "./src/shared/Post/Post.tsx":
/*!**********************************!*\
  !*** ./src/shared/Post/Post.tsx ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Post = void 0;\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar react_dom_1 = __importDefault(__webpack_require__(/*! react-dom */ \"./node_modules/@hot-loader/react-dom/index.js\"));\nvar post_less_1 = __importDefault(__webpack_require__(/*! ./post.less */ \"./src/shared/Post/post.less\"));\nvar axios_1 = __importDefault(__webpack_require__(/*! axios */ \"./node_modules/axios/index.js\"));\nvar CommentsList_1 = __webpack_require__(/*! ../CommentsList */ \"./src/shared/CommentsList/index.ts\");\nvar CommentFormContainer_1 = __webpack_require__(/*! ../CommentFormContainer */ \"./src/shared/CommentFormContainer/index.ts\");\nvar react_redux_1 = __webpack_require__(/*! react-redux */ \"./node_modules/react-redux/es/index.js\");\nvar react_router_dom_1 = __webpack_require__(/*! react-router-dom */ \"./node_modules/react-router-dom/esm/react-router-dom.js\");\nfunction Post(props) {\n    var _a = react_1.useState({ title: '', selftext: '', url: '' }), postData = _a[0], setPostData = _a[1];\n    var _b = react_1.useState({}), comments = _b[0], setComments = _b[1];\n    var token = react_redux_1.useSelector(function (state) { return state.token.token; });\n    var ref = react_1.useRef(null);\n    var history = react_router_dom_1.useHistory();\n    react_1.useEffect(function () {\n        function handleClick(event) {\n            var _a;\n            if (event.target instanceof Node && !((_a = ref.current) === null || _a === void 0 ? void 0 : _a.contains(event.target))) {\n                history.push('/posts');\n            }\n        }\n        document.addEventListener('click', handleClick);\n        return function () {\n            document.removeEventListener('click', handleClick);\n        };\n    }, []);\n    react_1.useEffect(function () {\n        var id = document.location.href.split('/posts/')[1];\n        axios_1.default.get(\"https://oauth.reddit.com/comments/\" + id + \".json?sr_detail=true&limit=20\", {\n            headers: { Authorization: \"bearer \" + token }\n        })\n            .then(function (resp) {\n            var post = resp.data;\n            setPostData(post[0].data.children[0].data);\n            setComments(post[1].data.children);\n        })\n            .catch(console.log);\n    }, []);\n    var node = document.querySelector('#modal_root');\n    if (!node)\n        return null;\n    return react_dom_1.default.createPortal((react_1.default.createElement(\"div\", { className: post_less_1.default.modal, ref: ref },\n        react_1.default.createElement(\"h2\", { className: post_less_1.default.title }, postData.title),\n        react_1.default.createElement(\"div\", { className: post_less_1.default.content },\n            postData.selftext,\n            /jpg|png$/.test(postData.url) ? react_1.default.createElement(\"img\", { src: postData.url, alt: '', className: post_less_1.default.img }) : null),\n        react_1.default.createElement(CommentFormContainer_1.CommentFormContainer, null),\n        react_1.default.createElement(CommentsList_1.CommentsList, { comments: comments }))), node);\n}\nexports.Post = Post;\n\n\n//# sourceURL=webpack:///./src/shared/Post/Post.tsx?");

/***/ }),

/***/ "./src/shared/Post/index.ts":
/*!**********************************!*\
  !*** ./src/shared/Post/index.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./Post */ \"./src/shared/Post/Post.tsx\"), exports);\n\n\n//# sourceURL=webpack:///./src/shared/Post/index.ts?");

/***/ })

})